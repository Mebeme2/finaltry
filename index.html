<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Robot AR Mission</title>
  <style>
    html, body {
      margin: 0; height: 100%; background: #000; color: #fff;
      font-family: system-ui, Arial, sans-serif;
      overflow: hidden;
    }
    #canvas-wrap { position: fixed; inset: 0; }
    #ui {
      position: fixed; left: 10px; bottom: 10px;
      display: flex; gap: 8px; z-index: 10;
    }
    button {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      padding: 8px 12px;
      border-radius: 999px;
      color: #fff; font-size: 14px;
      cursor: pointer;
    }
    #hint {
      position: fixed; top: 10px; left: 10px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      padding: 8px 12px; border-radius: 8px;
      font-size: 13px; max-width: 280px;
    }
  </style>
</head>
<body>
  <div id="canvas-wrap"></div>
  <div id="ui">
    <button id="resetBtn">Reset View</button>
  </div>
  <div id="hint">ðŸ“± Tap AR plane to place robot â†’ tap again to move it to the target.</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';

    let scene, camera, renderer, robot, bed;
    let reticle, placed = false, moving = false;

    const container = document.getElementById("canvas-wrap");

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 100);
      camera.position.set(0, 2, 4);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);

      setupLights();
      createGround();
      createRobot();
      createBed();

      // AR Button
      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      // Reticle
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.05, 0.06, 32).rotateX(-Math.PI/2),
        new THREE.MeshBasicMaterial({ color: 0x00ffff })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Place robot or move it on tap
      renderer.domElement.addEventListener("click", () => {
        if (renderer.xr.isPresenting && reticle.visible && !placed) {
          robot.position.setFromMatrixPosition(reticle.matrix);
          bed.position.copy(robot.position).add(new THREE.Vector3(0.5, 0, -0.5));
          bed.visible = true;
          placed = true;
        } else if (placed && !moving) {
          moveRobotToBed();
        }
      });

      document.getElementById("resetBtn").addEventListener("click", () => {
        camera.position.set(0, 2, 4);
        camera.lookAt(0, 1, 0);
      });

      window.addEventListener("resize", onWindowResize);
    }

    function setupLights() {
      const key = new THREE.DirectionalLight(0xffffff, 1);
      key.position.set(10, 15, 5); scene.add(key);
      scene.add(new THREE.AmbientLight(0x404040, 0.4));
    }

    function createGround() {
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.MeshPhysicalMaterial({ color: 0x0a0a0a, roughness: 0.8 })
      );
      ground.rotation.x = -Math.PI/2;
      ground.position.y = -0.01;
      scene.add(ground);
    }

    function createRobot() {
      robot = new THREE.Group();
      const bodyMat = new THREE.MeshPhysicalMaterial({ color: 0xf8f8f8, roughness: 0.15 });
      const plastic = new THREE.MeshPhysicalMaterial({ color: 0x2c2c2c, roughness: 0.3 });
      const rubber = new THREE.MeshPhysicalMaterial({ color: 0x111111, roughness: 0.9 });

      // Body
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.35, 0.2), bodyMat);
      body.position.set(0, 0.2, 0); robot.add(body);

      // Head
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.1, 0.05), plastic);
      head.position.set(0, 0.35, 0.1); robot.add(head);

      // Eyes
      const eyeGeom = new THREE.BoxGeometry(0.03, 0.03, 0.01);
      const eyeMat = new THREE.MeshPhysicalMaterial({
        color: 0x00ffff, emissive: 0x00aaaa, emissiveIntensity: 1.5,
        transparent: true, opacity: 0.95
      });
      const leftEye = new THREE.Mesh(eyeGeom, eyeMat.clone()); leftEye.position.set(-0.035, 0.35, 0.11); robot.add(leftEye);
      const rightEye = new THREE.Mesh(eyeGeom, eyeMat.clone()); rightEye.position.set(0.035, 0.35, 0.11); robot.add(rightEye);

      // Wheels
      const wheelGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 16);
      const positions = [[-0.12, 0.05, 0.07],[0.12,0.05,0.07],[-0.12,0.05,-0.07],[0.12,0.05,-0.07]];
      positions.forEach(p => {
        const wheel = new THREE.Mesh(wheelGeom, rubber);
        wheel.rotation.z = Math.PI/2; wheel.position.set(...p); robot.add(wheel);
      });

      scene.add(robot);
    }

    function createBed() {
      const bedGeo = new THREE.BoxGeometry(0.7, 0.4, 1.5);
      const bedMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      bed = new THREE.Mesh(bedGeo, bedMat);
      bed.visible = false;
      scene.add(bed);
    }

    function moveRobotToBed() {
      moving = true;
      const startPos = robot.position.clone();
      const endPos = bed.position.clone();
      endPos.y = startPos.y;

      let start = null;
      function move(t) {
        if (!start) start = t;
        const progress = (t - start) / 2000; // 2 sec
        if (progress < 1) {
          robot.position.lerpVectors(startPos, endPos, progress);
          requestAnimationFrame(move);
        } else {
          robot.position.copy(endPos);
          alert("Mission Successful. See you again!");
          moving = false;
        }
      }
      requestAnimationFrame(move);
    }

    function animate() {
      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
